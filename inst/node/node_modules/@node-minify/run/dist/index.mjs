// src/index.ts
import childProcess from "child_process";
var runCommandLine = ({ args, data, settings, callback }) => {
  if (settings && settings.sync) {
    return runSync({ settings, data, args, callback });
  }
  return runAsync({ data, args, callback });
};
var runAsync = ({ data, args, callback }) => {
  let stdout = "";
  let stderr = "";
  const child = childProcess.spawn("java", args, {
    stdio: "pipe"
  });
  child.on("error", console.log.bind(console, "child"));
  child.stdin.on("error", console.log.bind(console, "child.stdin"));
  child.stdout.on("error", console.log.bind(console, "child.stdout"));
  child.stderr.on("error", console.log.bind(console, "child.stderr"));
  child.on("exit", (code) => {
    if (code !== 0) {
      return callback && callback(new Error(stderr));
    }
    return callback && callback(null, stdout);
  });
  child.stdout.on("data", (chunk) => {
    stdout += chunk;
  });
  child.stderr.on("data", (chunk) => {
    stderr += chunk;
  });
  child.stdin.end(data);
};
var runSync = ({ settings, data, args, callback }) => {
  try {
    const child = childProcess.spawnSync("java", args, {
      input: data,
      stdio: "pipe",
      maxBuffer: settings && settings.buffer
    });
    const stdout = child.stdout.toString();
    const stderr = child.stderr.toString();
    const code = child.status;
    if (code !== 0) {
      return callback && callback(new Error(stderr));
    }
    return callback && callback(null, stdout);
  } catch (err) {
    return callback && callback(err);
  }
};
export {
  runCommandLine
};
/*!
 * node-minify
 * Copyright(c) 2011-2023 Rodolphe Stoclin
 * MIT Licensed
 */
//# sourceMappingURL=index.mjs.map